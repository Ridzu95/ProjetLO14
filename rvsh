#!/bin/bash

# La fonction checkParameters permet de vérifier les arguments rentrés par l'utilisateur.
# Etape 1 : vérifier le nobre d'arguments. Issues : 3 arguments et mode connect, 2 argument et mode admin, mode help.
# Etape 2 : en mode connect, on vérifie le nom de la machine entrée et le nom d'utilisateur (check de mot de passe à venir), ainsi que les accès.
# En mode admin, on demande le mot de passe. Le mot de passe est hashé dans le fichier admin.txt. L'input de l'admin est chiffré et on vérifie avec le mot de passe chiffré stocké.
# Si tout est bon, on peut passer la varible parametersOk à 1 pour passer à la suite.

function checkParameters {
  parametersOk=0
  if [[ $1 -eq 3 && $2 == '-connect' ]]; then
    virtuChecked=0
    if [[ $3 == $(grep -o ^$3 networkmap.txt) ]];then
      virtuChecked=1
      if [[ $4 == $(awk -F: '{print $1}' access.txt | grep -o $4) ]]; then
        if [[ $3 == $(grep $4 access.txt | grep -o $3) ]];then
          enteredPassword=0
          userPassword=$(grep -w $4 passwds.txt | cut -d':' -f2)
          read -s -p "Password for $4 : " enteredPassword
          if [[ $(echo $enteredPassword | sha512sum | cut -d' ' -f1) == $userPassword ]]; then
            parametersOk=1
          else
            echo "Mot de passe erroné. Veuillez réessayer."
            checkParameters $1 $2 $3 $4
          fi
        else
          echo "L'utilisateur $4 n'a pas accès à la machine $3."
        fi
      else
        echo "Utilisateur non identifié"
      fi
    else
      echo "Machine $3 non identifiée"
    fi
  elif [[ $1 -eq 1 && $2 ==  '-admin' ]]; then
    enteredPassword=0
    adminPassword=$(grep -w admin passwds.txt | cut -d':' -f2)
    read -s -p "Password for rvsh admin : " enteredPassword
    if [[ $(echo $enteredPassword | sha512sum | cut -d' ' -f1) == $adminPassword ]]; then
      parametersOk=1
    else
      echo "Mot de passe érroné. Veuillez réessayer."
      checkParameters $1 $2 $3 $4
    fi
  elif [[ $1 -eq 1 && $2 == 'help' ]]; then
    echo "
    Deux utilisations :

    Mode connect : vous permet de vous connecter à une machine du réseau virtuel --> rvsh -connect [machine] [utilisateur]
    Mode admin : vous permet d'éditer la configuration du réseau virtuel --> rvsh -admin
    "
    
  else
    echo "Mauvaise utilisation de la commande. Tapez 'rvsh help' pour plus d'informations"
  fi
}

# La fonction checkNetwork permet de vérifier si la machine auquelle on est connecté est reliée en réseau avec la machine sur laquelle on souhaite aller.
# On passe par le fichier networkmap qui indique pour chaque machine à quelles autres machines elle est reliée.

function checkNetwork {
  networkOk=0
  if [[ $2 == $(grep -w ^$1 networkmap.txt | grep -o $2) ]]; then
    echo "La machine $2 est bien reliée à la machine $1"
    networkOk=1
  else
    echo "La machine $2 n'est pas reliée à la machine $1"
  fi
}

# La fonction createMachineLog permet de créer une ligne dans le fichier de la machine avec le nom d'utilisateur, le terminal et l'heure de connexion.
# Elle crée également une ligne dans le fichier networklive, qui indique qui est connecté sur quelle machine.

function createMachineLog {
  # Si le fichier log machine n'existe pas, on le créée.
  if [[ ! -f $1 ]]; then 
    touch ./machines/$1.txt
  fi
  currentTerminal=$(tty)
  timeLog=$(date | cut -d' ' -f-4)
  echo "$2,$currentTerminal,$timeLog" >> ./machines/$1.txt
  echo "$2,$1,$timeLog" >> networklive.txt
}

# La fonction deleteMachineLog permet d'enlever les lignes créées par createMachineLog quand un utilisateur se déconnecte.
# Cela inclut aussi le passage de machine à machine. (on enlève le log de la machine précédente pour en créer un nouveau)

function deleteMachineLog {
  sed -i "s;$2,$currentTerminal,.*$;;g" ./machines/$1.txt
  sed -i '/^$/d' ./machines/$1.txt
  sed -i "s/$2,$1,.*$//g" networklive.txt
  sed -i '/^$/d' networklive.txt
}

function adminPrompt {
  trap "" 2
  trap "" 20
  read -p "$(echo -e $BOLD$YELLOW"rvsh"$RESET "> ")" userInput
  case $userInput in
    "") adminPrompt ;;
    "host") manageHostCommand ;;
    "users") manageUserCommand ;;
    "disconnect") disconnectCommand admin admin ;;
    *) adminHelpCommand ;;
  esac
}

function manageHostCommand {
  read -p "Saisissez le nom de la machine à administrer : " machineSelect
  if [[ ! -z $(grep -o ^$machineSelect networkmap.txt) ]]; then
    echo "
      Tapez 's' pour supprimer la machine.
      Tapez 'l' pour éditer ses liens.
    "
    read -p "Sélectionnez l'action à effectuer : " editChoice
    if [[ $editChoice == "s" ]]; then
      read -p "Etes-vous sûr de vouloir supprimer la machine $machineSelect ? (o/n) : " confirm
      if [[ $confirm == "o" ]]; then
        sed -i "/^$machineSelect.*/d" networkmap.txt
        sed -i "s/:$machineSelect//g" networkmap.txt
        echo "Machine supprimée."
        adminPrompt
      elif [[ $confirm == "n" ]]; then
        echo "Opération annulée."
        adminPrompt
      else
        echo "Erreur lors de l'éxecution."
        adminPrompt
      fi
    elif [[ $editChoice == "l" ]]; then
      echo "Voici les liens pour la machine $machineSelect"
      echo ""
      grep -w ^$machineSelect networkmap.txt | awk -F: '{for (i=2; i<=NF; i++) print $i}'
      echo ""
      echo "Redéfinissons les liens pour l'utilisateur $machineSelect. Liste des autres machines existantes sur le réseau : "
      echo ""
      grep -o -v ^$machineSelect networkmap.txt | awk -F: '{print $1}'
      echo ""
      read -p "Choix d'accès pour $machineSelect (séparés par des espaces) : " machinesChoice
      sed -i "/^$machineSelect/s/:.*$//" networkmap.txt
      set -- junk $machinesChoice
      shift
      for machine; do
        if [[ $machine == $(awk -F: '{print $1}' networkmap.txt | grep -o $machine) ]]; then
          echo "Machine $machine identifiée. Ajout de lien."
          sed -i "/^$machineSelect/s/$/:$machine/" networkmap.txt
          sed -i "/^$machine/s/$/:$machineSelect/" networkmap.txt
        else
          echo "Machine $machine non identifiée."
        fi
      done
      adminPrompt
    else
      echo "Erreur lors de l'éxecution."
      adminPrompt
    fi
  else
    read -p "Cette machine n'existe pas, voulez-vous la créer ? (o/n) : " createChoice
    if [[ $createChoice == "o" ]]; then
      echo "Définissons les liens pour la machine $machineSelect. Liste des autres machines existantes sur le réseau : "
      echo ""
      awk -F: '{print $1}' networkmap.txt
      echo ""
      echo "$machineSelect" >> networkmap.txt
      read -p "Choix des liens pour $machineSelect (séparés par des espaces) : " machinesChoice
      set -- junk $machinesChoice
      shift
      for machine; do
        if [[ $machine == $(awk -F: '{print $1}' networkmap.txt | grep -o $machine) ]]; then
          echo "Machine $machine identifiée. Ajout de lien."
          sed -i "/^$machineSelect/s/$/:$machine/" networkmap.txt
          sed -i "/^$machine/s/$/:$machineSelect/" networkmap.txt
        else
          echo "Machine $machine non identifiée."
        fi
      done
      echo ""
      adminPrompt
    elif [[ $createChoice == "n" ]]; then
      adminPrompt
    else
      echo "Erreur lors de l'éxecution."
      adminPrompt
    fi
  fi
}

function manageUserCommand {
  read -p "Saisissez le nom de l'utilisateur à administrer : " userSelect
  if [[ ! -z $(grep -o $userSelect access.txt) ]]; then
    echo "
      Tapez 's' pour supprimer l'utilisateur.
      Tapez 'a' pour éditer ses accès.
    "
    read -p "Sélectionnez l'action à effectuer : " editChoice
    if [[ $editChoice == "s" ]]; then
      read -p "Etes-vous sûr de vouloir supprimer l'utilisateur $userSelect ? (o/n) : " confirm
      if [[ $confirm == "o" ]]; then
        sed -i "s/^$userSelect.*//g" access.txt
        sed -i "s/^$userSelect.*//g" passwds.txt
        sed -i '/^$/d' access.txt
        sed -i '/^$/d' passwds.txt
        echo "Utilisateur supprimé."
        adminPrompt
      elif [[ $confirm == "n" ]]; then
        echo "Opération annulée."
        adminPrompt
      else
        echo "Erreur lors de l'éxecution."
        adminPrompt
      fi
    elif [[ $editChoice == "a" ]]; then
      echo "Voici les accès machine pour l'utilisateur $userSelect"
      echo ""
      grep -w $userSelect access.txt | awk -F: '{for (i=2; i<=NF; i++) print $i}'
      echo ""
      echo "Redéfinissons les accès pour l'utilisateur $userSelect. Liste des machines existantes sur le réseau : "
      echo ""
      awk -F: '{print $1}' networkmap.txt
      echo ""
      read -p "Choix d'accès pour $userSelect (séparés par des espaces) : " machinesChoice
      sed -i "/$userSelect/s/:.*$//" access.txt
      set -- junk $machinesChoice
      shift
      for machine; do
        if [[ $machine == $(awk -F: '{print $1}' networkmap.txt | grep -o $machine) ]]; then
          echo "Machine $machine identifiée. Ajout d'accès."
          sed -i "/$userSelect/s/$/:$machine/" access.txt
        else
          echo "Machine $machine non identifiée."
        fi
      done
      adminPrompt
    else
      echo "Erreur lors de l'éxecution."
      adminPrompt
    fi
  else
    read -p "Cet utilisateur n'existe pas, voulez-vous le créer ? (o/n) : " createChoice
    if [[ $createChoice == "o" ]]; then
      echo "$userSelect" >> access.txt
      echo "Définissons les accès pour l'utilisateur $userSelect. Liste des machines existantes sur le réseau : "
      echo ""
      awk -F: '{print $1}' networkmap.txt
      read -p "Choix d'accès pour $userSelect (séparés par des espaces) : " machinesChoice
      set -- junk $machinesChoice
      shift
      for machine; do
        if [[ $machine == $(awk -F: '{print $1}' networkmap.txt | grep -o $machine) ]]; then
          echo "Machine $machine identifiée. Ajout d'accès."
          sed -i "/$userSelect/s/$/:$machine/" access.txt
        else
          echo "Machine $machine non identifiée."
        fi
      done
      read -p "Saisissez un mot de passe pour l'utilisateur $userSelect : " passwordChoice
      echo "$userSelect" >> passwds.txt
      cryptedPasswordChoice=$(echo $passwordChoice | sha512sum | cut -d' ' -f1)
      sed -i "/^$userSelect/s/$/:$cryptedPasswordChoice/" passwds.txt
      echo "Utilisateur créé."
      adminPrompt
    elif [[ $createChoice == "n" ]]; then
      adminPrompt
    else
      echo "Erreur lors de l'éxecution."
      adminPrompt
    fi
  fi
}

# Le prompt utilisateur affiche "utilisateur@machine >" (en jaune) et attend une commande de la part de l'utilisateur.
# On met un case pour rassembler l'ensemble des commandes possibles.
# Le case permet la redirection vers les commandes créées.

function connectPrompt {
  trap "" 2
  trap "" 20
  read -p "$(echo -e $BOLD$YELLOW"$2@$1"$RESET "> " )" userInput 
  case $userInput in
    "") connectPrompt $1 $2 ;;
    "who") whoCommand $1 $2 ;;
    "rusers") rusersCommand $1 $2 ;;
    "rhost") rhostCommand $1 $2 ;;
    "connect") connectCommand $1 $2 ;;
    "disconnect") disconnectCommand $1 $2;;
		"su") suCommand $1 $2 ;;
		"passwd") passwdCommand $1 $2 ;;
		"finger") fingerCommand $1 $2 ;;
    *) helpCommand $1 $2 ;;
  esac
}

function whoCommand {
  echo "Utilisateurs connectés sur la machine $1 :"
  awk -F, '{print $1," est connecté avec le terminal ",$2," depuis ",$3}' ./machines/$1.txt
  connectPrompt $1 $2
}

function rusersCommand {
  echo "Liste des utilisateurs connectés sur le réseau :"
  awk -F, '{print $1," est connecté sur la machine ",$2, " depuis ",$3}' networklive.txt
  connectPrompt $1 $2
}

function rhostCommand {
  echo "Liste des machines reliées à la machine $1 :"
  grep -w ^$1 networkmap.txt | awk -F: '{for (i=2; i<=NF; i++) print $i}' 
  connectPrompt $1 $2
}

# La fonction connectCommand permet de passer d'une machine à une autre.
# On saisit le nom de la machine sur laquelle on souhaite se connecter et on vérifie les paramètres utilisateur et machine.
# Si tout est bon, on enlève le log de connexion de la machine actuelle, et on crée un log concernant la machine sur laquelle on se connecte.
# Enfin, on affiche le nouveau prompt utilisateur.

function connectCommand {
  echo ""
  newMachine=0
  read -p "Saisissez le nom de la machine sur laquelle vous souhaitez vous connecter : " newMachine
  checkParameters 3 -connect $newMachine $2
  if [[ $parametersOk == 1 ]]; then
    echo "Vérification du réseau virtuel"
    checkNetwork $1 $newMachine
    if [[ $networkOk == 1 ]]; then
      deleteMachineLog $1 $2
      createMachineLog $newMachine $2
      clear
      connectPrompt $newMachine $2
    else
      connectPrompt $1 $2
    fi
  else
    connectPrompt $1 $2
  fi
}

# La fonction su permet de changer d'utilisateur
# On vérifie que l'utilisateur a accès à la machine sur laquelle on est connecté.

function suCommand {
	echo ""
	read -p "Saisir le nom d'utilisateur : " util
	checkParameters 3 -connect $1 $util
	if [[ $parametersOk == 1 ]]; then
			clear
			deleteMachineLog $1 $2
			createMachineLog $1 $util
			connectPrompt $1 $util
	else
    connectPrompt $1 $2
	fi
}

# La fonction finger affiche les informations complémentaires sur l'uilisateur : nom de login, nom réel, terminal, date de login, etc.

function fingerCommand {
	nom=$(grep -w $2 infos.txt | cut -d':' -f2)
	datelog=$(cat ./machines/$1.txt | cut -d',' -f3)
	echo "
	Nom de login : $2
	Nom : $nom
	Terminal : $currentTerminal
	Date de login : $datelog
	"
	connectPrompt $1 $2
}

#function passwdCommand {
		
#}

function helpCommand {
  echo "
  Commandes à votre disposition sur cette machine :
  
  who : Cette commande permet d’accéder à l’ensemble des utilisateurs connectés sur la machine.
  rusers : Cette commande permet d’accéder à la liste des utilisateurs connectés sur le réseau.
  rhost : Cette commande doit renvoyer la liste des machines rattachées à la machine. 
  connect : Cette commande permet à l’utilisateur de se connecter à une autre machine du réseau.
  su : Cette commande permet de changer d'utilisateur sur cette machine.
  passwd : Cette commande permet de changer de mot de passe sur l'ensemble du réseau virtuel.
  finger : Cette commande affiche les informations complémentaires de l'utilisateur.

  Pour vous déconnecter, utilisez la commande disconnect.
	"
  connectPrompt $1 $2
}

function disconnectCommand {
  echo "Déconnexion de la machine $1 sur le terminal $currentTerminal ..."
  deleteMachineLog $1 $2
  clear
}

# Quand l'utilisateur rentre sa commande rvsh : on vérifie les arguments.
# Si tout est bon --> prompt admin ou prompt utilisateur.

function rvsh {
  RESET="\033[0m"
  BOLD="\033[1m"
  YELLOW="\033[38;5;11m"
  checkParameters $# $1 $2 $3
  if [[ $parametersOk == 1 ]]; then
    clear
    if [[ $1 == "-admin" ]]; then
      createMachineLog admin admin
      adminPrompt
    else
      createMachineLog $2 $3
      connectPrompt $2 $3
    fi
  fi
}

rvsh $@
exit 0
